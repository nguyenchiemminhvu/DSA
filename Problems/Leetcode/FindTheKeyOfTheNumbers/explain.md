## Problem

https://leetcode.com/problems/find-the-key-of-the-numbers/description/

```
You are given three positive integers num1, num2, and num3.

The key of num1, num2, and num3 is defined as a four-digit number such that:

Initially, if any number has less than four digits, it is padded with leading zeros.
The ith digit (1 <= i <= 4) of the key is generated by taking the smallest digit among the ith digits of num1, num2, and num3.
Return the key of the three numbers without leading zeros (if any).

Example 1:

Input: num1 = 1, num2 = 10, num3 = 1000

Output: 0

Explanation:

On padding, num1 becomes "0001", num2 becomes "0010", and num3 remains "1000".

The 1st digit of the key is min(0, 0, 1).
The 2nd digit of the key is min(0, 0, 0).
The 3rd digit of the key is min(0, 1, 0).
The 4th digit of the key is min(1, 0, 0).
Hence, the key is "0000", i.e. 0.

Example 2:

Input: num1 = 987, num2 = 879, num3 = 798

Output: 777

Example 3:

Input: num1 = 1, num2 = 2, num3 = 3

Output: 1

Constraints:

1 <= num1, num2, num3 <= 9999
```

## Observations

1. **Problem Understanding**: We need to generate a 4-digit key by comparing corresponding digits from three numbers and taking the minimum at each position.

2. **Key Requirements**:
   - All numbers are conceptually treated as 4-digit numbers with leading zeros if needed
   - For each digit position (1st, 2nd, 3rd, 4th), we take the minimum digit among the three numbers
   - The final result should not have leading zeros (return as integer)

3. **Digit Extraction Strategy**: 
   - Since all inputs are ≤ 9999, we can treat them as 4-digit numbers with leading zeros
   - For any number `n`, the digits from right to left are:
     - 1st digit (rightmost): `n % 10`
     - 2nd digit: `(n // 10) % 10` 
     - 3rd digit: `(n // 100) % 10`
     - 4th digit (leftmost): `(n // 1000) % 10`

4. **Key Insights**:
   - No need for string conversion or padding - mathematical operations suffice
   - The solution processes digits from right to left but constructs the result correctly
   - Missing digits (for numbers < 1000, < 100, < 10) automatically become 0 through integer division

5. **Examples Analysis**:
   - **Example 1**: `1, 10, 1000` → `"0001", "0010", "1000"` → min digits: `[0,0,0,0]` → `0`
   - **Example 2**: `987, 879, 798` → `"0987", "0879", "0798"` → min digits: `[0,7,7,7]` → `777`
   - **Example 3**: `1, 2, 3` → `"0001", "0002", "0003"` → min digits: `[0,0,0,1]` → `1`

## Solution

**Approach**: Direct Mathematical Digit Extraction

The solution uses mathematical operations to extract individual digits from each number and computes the minimum for each position:

```python
class Solution:
    def generateKey(self, a: int, b: int, c: int) -> int:
        k1 = min(a % 10, b % 10, c % 10)
        k2 = min((a // 10) % 10, (b // 10) % 10, (c // 10) % 10)
        k3 = min((a // 100) % 10, (b // 100) % 10, (c // 100) % 10)
        k4 = min((a // 1000) % 10, (b // 1000) % 10, (c // 1000) % 10)
        return k4 * 1000 + k3 * 100 + k2 * 10 + k1
```

**Algorithm Steps**:

1. **Extract 1st digit (ones place)**: `k1 = min(a % 10, b % 10, c % 10)`
   - Gets the rightmost digit of each number

2. **Extract 2nd digit (tens place)**: `k2 = min((a // 10) % 10, (b // 10) % 10, (c // 10) % 10)`
   - Divides by 10 to shift right, then takes modulo 10 to get the digit

3. **Extract 3rd digit (hundreds place)**: `k3 = min((a // 100) % 10, (b // 100) % 10, (c // 100) % 10)`
   - Divides by 100 to shift right, then takes modulo 10 to get the digit

4. **Extract 4th digit (thousands place)**: `k4 = min((a // 1000) % 10, (b // 1000) % 10, (c // 1000) % 10)`
   - Divides by 1000 to shift right, then takes modulo 10 to get the digit

5. **Construct Result**: `k4 * 1000 + k3 * 100 + k2 * 10 + k1`
   - Combines the minimum digits to form the final 4-digit number
   - Leading zeros are automatically handled by returning as integer

**Time Complexity**: O(1) - Fixed number of operations regardless of input size
**Space Complexity**: O(1) - Only using constant extra space

**Example Walkthrough** with `a = 987, b = 879, c = 798`:

| Position | Operation | a | b | c | Min |
|----------|-----------|---|---|---|-----|
| k1 (ones) | `n % 10` | 7 | 9 | 8 | 7 |
| k2 (tens) | `(n // 10) % 10` | 8 | 7 | 9 | 7 |
| k3 (hundreds) | `(n // 100) % 10` | 9 | 8 | 7 | 7 |
| k4 (thousands) | `(n // 1000) % 10` | 0 | 0 | 0 | 0 |

**Result**: `0 × 1000 + 7 × 100 + 7 × 10 + 7 = 777`

**Alternative Approaches**:
1. **String-based**: Convert to strings, pad with zeros, compare character by character
2. **Loop-based**: Use a loop to process each digit position
3. **Array-based**: Store digits in arrays and process

The given solution is optimal as it's direct, readable, and avoids string operations or loops.

# Tags

- **Difficulty**: Easy
- **Topics**: Math, Implementation, Digit Manipulation
- **Companies**: -
- **Patterns**: Digit Extraction, Mathematical Operations
- **Similar Problems**: 
  - Maximum Difference by Remapping a Digit
  - Minimum Sum of Four Digit Number After Splitting Digits
  - Check if Number Has Equal Digit Count and Digit Value

